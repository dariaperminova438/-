# Сравнение создания массива (списка) и организация стека на Java, C++ и Python 

(Перминова Дарья УИБО-10-24)

# Создание списка

# Java

-Формула создания коллекции:
ArrayList<Тип> имя = new ArrayList<> ();

ArrayList<String>-
объявляем, что переменная colors будет хранить список (ArrayList), состоящий только из строк (String).

new ArrayList<>() - оператор new создает в памяти новый экземпляр (объект) класса ArrayList. Диамантные скобки <> остаются пустыми (сокращенная форма, компилятор сам подставит String).

-Формула добавления элемента: имя_списка.add (элемент);
Метод . add ( ) - это основная операция для помещения данных в конец списка.

-Формула вывода содержимого:
System.out. printin(имя_списка
Когда мы передаем целый список
в System. out.println(), Java
автоматически вызывает у него метод toString (), который возвращает удобное для чтения строковое представление всех элементов в квадратных скобках:
[Красный, Синий, Белый].

# Python

В отличие от Java, где нужно явно импортировать класс ArrayList, B Python список (list) - это встроенная, фундаментальная структура данных. Это означает, что он доступен в любой программе на Python по умолчанию, без необходимости подключения дополнительных модулей.

Создание списка с помощью конструктора list().

# C++

В C++ для использования стандартных библиотек необходимо подключить соответствующие заголовочные файлы. Это аналог импорта в Java, но работающий на уровне препроцессора.

#include <iostream> -
подключает библиотеку для ввода/ вывода (нужна для std: : cout и std: : endl).

#include <vector> - подключает класс std: : vector, который является аналогом ArrayList B Java. Это шаблонный класс динамического массива.

#include <string> - подключает класс std::string для работы со строками.

-Формула объявления вектора: 

std::vector<Тип> имя_ вектора;

std:: vector - шаблонный класс, реализующий динамический массив.

<std: :string> - параметр шаблона. Указывает компилятору, что данный вектор будет хранить элементы типа 
std: : string. Это обеспечивает строгую типизацию, как и в Java.
std: : - указание на пространство имен std (standard), в котором находятся все стандартные библиотеки С++.

# Организация стека

# Java

Для работы со стеком в Java необходимо импортировать соответствующий класс из стандартной библиотеки.

import - ключевое слово для подключения классов.

java.util.Stack - класс, реализующий структуру данных "стек" по принципу LIFO (Last-In, First-Out)

-Формула создания стека:
Stack<Тип> имя стека = new
Stack<>();

Stack<Integer> - объявление переменной типа "стек, содержащий целые числа".

-"Формула" добавления: имя_стека. push (элемент) ;

Метод . push () помещает элемент на вершину стека.

При передаче стека в
System.out.printin () автоматически вызывается метод toString (), который возвращает строковое представление стека.

-"Формула" извлечения:
Тип переменная = имя_ стека.рор ();

# Python

-Формула создания стека:
имя_стека = []

-"Формула" добавления: имя_стека.append (элемент)

Метод . append ( ) добавляет элемент в конец списка, что соответствует вершине стека.

# C++

-Формула создания стека: std::stack<Тип> имя стека;

std::stack<int> - объявление стека, содержащего целые числа.

-"Формула" добавления:
имя_стека.push (значение) ;

Метод .push () помещает элемент на вершину стека. Элементы добавляются в порядке: 10, 20, 30, 40.

-"Формула" чтения:
Тип переменная = имя_стека.top();

Метод . top () возвращает значение верхнего элемента без его удаления.
Стек остается неизменным: L10,
20, 30, 40].

-"Формула" удаления:
имя_стека.ор();

Метод . рор ( ) удаляет верхний элемент из стека.

# Вывод:

Каждый язык предлагает уникальный подход к работе с базовыми структурами данных, отражающий его общую философию:

Java демонстрирует строгую объектно-ориентированную модель с акцентом на безопасность и типобезопасность. Здесь даже простые структуры данных реализованы как классы с богатым API.

Python следует принципу простоты и практичности. Встроенные списки идеально подходят для реализации стека, что делает код лаконичным и читаемым.

С++ предлагает максимальный контроль и производительность через шаблонные контейнеры, но требует от программиста большей внимательности.
